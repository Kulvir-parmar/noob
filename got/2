package main

import (
	"fmt"
	"math/rand"
	"runtime"
	"sync"
)

func main() {
	done := make(chan bool)
	defer close(done)

	randomNumStream := getRandomNum(done)
	primes := primeCheck(done, randomNumStream)

	// This Approach with slow bottleneck
	// Every calculation is concurrent but not prallel
	// spin other goroutines to do calculations for same task
	for primeNum := range takePrime(done, primes, 10) {
		fmt.Println(primeNum)
	}

	// The parallel approach
	cpus := runtime.NumCPU()
	fmt.Println(cpus)
}

func takePrime(done <-chan bool, primes <-chan int, numPrimes int) <-chan int {
	taken := make(chan int)
	go func() {
		defer close(taken)

		for num := 0; num < numPrimes; num++ {
			select {
			case <-done:
				return
			case taken <- <-primes:
			}
		}
	}()
	return taken
}

func primeCheck(done chan bool, stream <-chan int) <-chan int {
	isPrime := func(random int) bool {
		for idx := random - 1; idx > 1; idx-- {
			if random%idx == 0 {
				return false
			}
		}
		return true
	}

	primes := make(chan int)
	go func() {
		defer close(primes)

		for {
			select {
			case <-done:
				return
			case num := <-stream:
				if isPrime(num) {
					primes <- num
				}
			}
		}
	}()
	return primes
}

func getRandomNum(done <-chan bool) <-chan int {
	stream := make(chan int)
	go func() {
		defer close(stream)
		for {
			select {
			case <-done:
				return
			case stream <- rand.Intn(100000000):
			}
		}
	}()
	return stream
}

// Send data from multiple go routines to same channel
// Sol: make a goroutine to wait until all other goroutines are done sending data
// Close the channel when Done.
func second() {
	channel := make(chan int, 10)
	var wg sync.WaitGroup

	wg.Add(2)
	go func() {
		defer wg.Done()

		for j := 0; j < 10; j++ {
			send := j
			channel <- send
		}
		fmt.Println("-----1st Go Routine is ended here-----")
	}()

	go func() {
		defer wg.Done()

		for j := 0; j < 10; j++ {
			send := j
			channel <- send
		}
		fmt.Println("-----2nd Go Routine is ended here-----")
	}()

	go func() {
		wg.Wait()
		defer close(channel)
	}()

	mp := make(map[int]int)
	for kv := range channel {
		mp[kv]++
	}
	fmt.Printf("The map is:\n %v\n", mp)
}
